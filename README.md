# Docker-compose

## Стек php + apache + mariaDB + phpMyAdmin

Данный репозиторий представляет собой небольшой тест Docker для компании Каскад-Технологии.

Основной целью применения Docker является быстрое развертывание окружения на локальных компьютерах. Также
данное ПО обеспечивает легкую переносимость приложений благодаря применению контейнезированного подхода.

Применение Docker в нынешнее время обосновано тем, что раньше программист писал код и документацию к нему в которой
описывалось какие необходимые пакеты должен установить системный администратор на сервере, чтобы данное приложение
запустилось на production. Такой подход не удобен тем, что пакеты необходимые для работы приложения постоянно добавляются,
тем самым документация усложняется и тем самым увеличивается шанс упустить какой-либо пакет. Таким образом, 
если программист забудет указать какой либо пакет в документации и передаст ее системному администратору,
то его код на production работать не будет.

Сейчас Docker позволяет программисту самостоятельно описывать среду в которой должно работать приложение, то есть
он создает свой образ окружения(image) с помощью Dockerfile. Далее данный файл передается системному администратору,
системный администратор запускает контейнер этого образа на сервере и приложение работает точно также как и работало
на локальном компьютере программиста.

В ``Dockerfile`` мы создаем свой образ на основе уже существующего образа и дополняем его своими командами.В ``Dockerfile`` 
используются различные инструкции, чтобы определить структуру и настройку образа Docker. Вот как отличаются команды ``RUN``, ``CMD`` и ``ENTRYPOINT``:

Команды, исполняемые с помощью ``RUN``, обычно связаны с установкой пакетов, настройкой окружения или другими операциями, которые влияют на содержимое Docker образа.
Команды использующие ``RUN`` создают новый слой в образе, поэтому хорошой практикой считается минимизация использования данного ключевого слова.

``CMD``: Эта инструкция определяет команду или скрипт, который будет выполняться по умолчанию при запуске контейнера Docker. 
Если в ``Dockerfile`` указано несколько ``CMD`` инструкций, то будет выполнена только последняя

``ENTRYPOINT``: Эта инструкция определяет команду, которую следует выполнить при запуске контейнера. В отличие от ``CMD``, 
``ENTRYPOINT`` не может быть переопределен при использовании ``docker run`` с дополнительным параметром (если не указан флаг 
**--entrypoint**). Если в Dockerfile используется и ``ENTRYPOINT``, и ``CMD``, то ``CMD`` будет использоваться как аргументы для ``ENTRYPOINT``.

Созданный образ подключается к docker-compose файлу с помощью ключевого слова ``build: <Directory Dockerfile>``. В нашем
случае так как Dockerfile и файл docker-compose находятся в одной директории, то нам достаточно указать ``.``.

Если мы хотим указать образ из Docker Hub (библиотека образов), то необходимо воспользоваться ключевым словом ``image: <imagename:tag>``. 
Далее мы можем настроить имя контейнера с помощью ключевого слова ``container_name: <containername>``.

Следующим кючевым словом является ``volumes`` с помощью него мы можем перенести файлы своего проекта в контейнер. Этот 
удобный подход позволяет сохранять данные в случае если контейнер будет удален и создан заново. В Docker есть несколько 
видов ``volumes``, но в данном проекте применяются только один тип ``volumes`` - Host Volumes, то есть мы явно указываем
какие файлы или директории будут перенесы в определенном место в контейнере. Пример этому является фрагмент кода из контейнера 
php-apache:

    volumes: 
    - './:/var/www/html/'

Клюевое слово ``environment`` позволяет указать переменные которые будут доступны в образе. Это хорошо видно в контейнере phpmyadmin:

    environment:
      MYSQL_ROOT_PASSWORD: root
      PMA_HOST: db
      PMA_USER: root
      PMA_PASSWORD: root

``depends_on`` позволяет указать зависимость контейнера от других контейнеров и обеспечить корректную работу контейнера.

Чтобы запустить данный проект у вас должен быть скачан docker и docker-compose.

Затем командой ``docker compose up`` вы можете запустить контейнеры apache, php, mariaDB, phpMyAdmin.

Для остановки всех контейнеров воспользуйтесь командой ``docker compose stop``. В этом случае контейнеры 
будут остановлены, но не удалены для удаления контейнеров можно воспльзоваться следующими командами:

1. ``docker rm <containerID or containerName:tag>`` - в данном случае мы можем удалить один или более контейнеров, но что если контейнеров много?
2. ``docker container prune -f`` - команда удаляет все остановленные контейнеры (ключ -f указывает на то что удаления произойдет без подтверждения)

Для того чтобы убедиться какие контейнеры сейчас работают используйте ``docker ps``, а если хотите посмотреть
все контейнеры, которые на данный момент существуют воспользуйтесь этой же комнадой добавив ключ ``-a``

